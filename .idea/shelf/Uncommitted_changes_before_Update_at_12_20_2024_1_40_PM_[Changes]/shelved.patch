Index: plots.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import numpy as np\r\nimport pandas as pd\r\nimport os\r\nimport matplotlib.pyplot as plt\r\nimport utils as uts\r\nimport K_fit\r\n\r\n\r\ndef adjust_dataframe():\r\n    df = pd.read_csv('results/K_DNA-DNA_in_crowder_solutions.csv')\r\n\r\n    df[['K', 'K_err']] = df['K'].str.split('±', expand=True)\r\n    df[['D', 'D_err']] = df['D'].str.split('±', expand=True)\r\n    df['K'] = pd.to_numeric(df['K'], errors='coerce')\r\n    df['K_err'] = pd.to_numeric(df['K_err'], errors='coerce')\r\n    df['D'] = pd.to_numeric(df['D'], errors='coerce')\r\n    df['D_err'] = pd.to_numeric(df['D_err'], errors='coerce')\r\n    return(df)\r\n\r\n\r\ndef K_DNA_vs_crowder_weight_percent():\r\n    df = adjust_dataframe()\r\n    styles = {\r\n        'buffer': {'x': [0], 'y': [1760000000], 'yerr': [311872000], 'color': '#868788', 'marker': '*', 'ms': 9.5, 'mec': '#000000', 'label': 'buffer'},\r\n        'EGly': {'color': '#2d642a', 'marker': '.', 'ms': 12, 'mec': '#000000', 'label': 'EGly'},\r\n        'PEG200': {'color': '#b3daff', 'marker': 'd', 'ms': 7, 'mec': '#000000', 'label': 'PEG 200'},\r\n        'PEG400': {'color': '#640024', 'marker': '^', 'ms': 7, 'mec': '#000000', 'label': 'PEG 400'},\r\n        'PEG600': {'color': '#ff730f', 'marker': 'h', 'ms': 7, 'mec': '#000000', 'label': 'PEG 600'},\r\n        'PEG1000': {'color': '#fed85d', 'marker': 'P', 'ms': 6.5, 'mec': '#000000', 'label': 'PEG 1k'},\r\n        'PEG1500': {'color': '#142cd7', 'marker': 'p', 'ms': 7, 'mec': '#000000', 'label': 'PEG 1.5k'},\r\n        'PEG3000': {'color': '#ac1416', 'marker': 's', 'ms': 6, 'mec': '#000000', 'label': 'PEG 3k'},\r\n        'PEG6000': {'color': '#674ea7', 'marker': 'D', 'ms': 5.5, 'mec': '#000000', 'label': 'PEG 6k'},\r\n        'PEG12000': {'color': '#709d74', 'marker': 'v', 'ms': 7, 'mec': '#000000', 'label': 'PEG 12k'},\r\n        'PEG20000': {'color': '#00cccc', 'marker': 'X', 'ms': 7, 'mec': '#000000', 'label': 'PEG 20k'},\r\n        'PEG35000': {'color': '#b28092', 'marker': 'h', 'ms': 7, 'mec': '#000000', 'label': 'PEG 35k'}\r\n    }\r\n\r\n    plt.figure(figsize=(7, 5))\r\n\r\n    # Plot data for each 'crowder'\r\n    for crowder, style in styles.items():\r\n        if crowder == 'buffer':\r\n            plt.errorbar(style['x'], style['y'], yerr=style['yerr'], color=style['color'], marker=style['marker'],\r\n                         mec=style['mec'], linestyle='none', lw=1, ms=style['ms'], elinewidth=1, capsize=3, capthick=1, label=style['label'])\r\n        else:\r\n            subset = df[df['crowder'] == crowder]\r\n            plt.errorbar(subset['wt_%'], subset['K'], yerr=subset['K_err'], color=style['color'], marker=style['marker'],\r\n                         mec=style['mec'], linestyle='none', lw=1, ms=style['ms'], elinewidth=1, capsize=3, capthick=1, label=style['label'])\r\n\r\n    # Plot formatting\r\n    plt.title('$K_{DNA-DNA}$ vs crowder wt.% change', fontsize=18)\r\n    plt.xlabel('crowder wt.%', fontsize=16)\r\n    plt.ylabel('$K_{DNA-DNA}$ [M$^{-1}$]', fontsize=16)\r\n    plt.xticks(fontsize=12)\r\n    plt.yticks(fontsize=12)\r\n    plt.yscale('log')\r\n    plt.xlim(-2, 52)\r\n    plt.legend(frameon=True, loc='lower left', fontsize=8)\r\n    plt.savefig('plots/K_DNA_vs_crowder_weight_percent.png', bbox_inches='tight', transparent=True, dpi=300)\r\n    return plt.show()\r\n\r\n\r\ndef D_DNA_vs_crowder_weight_percent():\r\n    df = adjust_dataframe()\r\n    styles = {\r\n        'buffer': {'x': [0], 'y': [151], 'yerr': [2.1], 'color': '#868788', 'marker': '*', 'ms': 9.5, 'mec': '#000000', 'label': 'buffer'},\r\n        'EGly': {'color': '#2d642a', 'marker': '.', 'ms': 12, 'mec': '#000000', 'label': 'EGly'},\r\n        'PEG200': {'color': '#b3daff', 'marker': 'd', 'ms': 7, 'mec': '#000000', 'label': 'PEG 200'},\r\n        'PEG400': {'color': '#640024', 'marker': '^', 'ms': 7, 'mec': '#000000', 'label': 'PEG 400'},\r\n        'PEG600': {'color': '#ff730f', 'marker': 'h', 'ms': 7, 'mec': '#000000', 'label': 'PEG 600'},\r\n        'PEG1000': {'color': '#fed85d', 'marker': 'P', 'ms': 6.5, 'mec': '#000000', 'label': 'PEG 1k'},\r\n        'PEG1500': {'color': '#142cd7', 'marker': 'p', 'ms': 7, 'mec': '#000000', 'label': 'PEG 1.5k'},\r\n        'PEG3000': {'color': '#ac1416', 'marker': 's', 'ms': 6, 'mec': '#000000', 'label': 'PEG 3k'},\r\n        'PEG6000': {'color': '#674ea7', 'marker': 'D', 'ms': 5.5, 'mec': '#000000', 'label': 'PEG 6k'},\r\n        'PEG12000': {'color': '#709d74', 'marker': 'v', 'ms': 7, 'mec': '#000000', 'label': 'PEG 12k'},\r\n        'PEG20000': {'color': '#00cccc', 'marker': 'X', 'ms': 7, 'mec': '#000000', 'label': 'PEG 20k'},\r\n        'PEG35000': {'color': '#b28092', 'marker': 'h', 'ms': 7, 'mec': '#000000', 'label': 'PEG 35k'}\r\n    }\r\n\r\n    plt.figure(figsize=(7, 5))\r\n\r\n    # Plot data for each 'crowder'\r\n    for crowder, style in styles.items():\r\n        if crowder == 'buffer':\r\n            plt.errorbar(style['x'], style['y'], yerr=style['yerr'], color=style['color'], marker=style['marker'],\r\n                         mec=style['mec'], linestyle='none', lw=1, ms=style['ms'], elinewidth=1, capsize=3, capthick=1, label=style['label'])\r\n        else:\r\n            subset = df[df['crowder'] == crowder]\r\n            plt.errorbar(subset['wt_%'], subset['D'], yerr=subset['D_err'], color=style['color'], marker=style['marker'],\r\n                         mec=style['mec'], linestyle='none', lw=1, ms=style['ms'], elinewidth=1, capsize=3, capthick=1, label=style['label'])\r\n\r\n    # Plot formatting\r\n    plt.title('$D_{DNA}$ vs crowder wt.% change', fontsize=18)\r\n    plt.xlabel('crowder wt.%', fontsize=16)\r\n    plt.ylabel('$D_{DNA}$ [µm$^{2}$/s]', fontsize=16)\r\n    plt.xticks(fontsize=12)\r\n    plt.yticks(fontsize=12)\r\n    plt.yscale('log')\r\n    plt.xlim(-2, 52)\r\n    plt.legend(frameon=True, loc='lower left', fontsize=8)\r\n    plt.savefig('plots/D_DNA_vs_crowder_weight_percent.png', bbox_inches='tight', transparent=True, dpi=300)\r\n    return plt.show()\r\n\r\n\r\ndef D_Na_vs_crowder_weight_percent():\r\n\r\n    # Load CSV files into global variables and dictionary\r\n    path = 'source_data/D_Na_and_D_crowder'\r\n    crowders = {}\r\n    for file in os.listdir(path):\r\n        if file.endswith('.csv'):\r\n            var_name = os.path.splitext(file)[0]\r\n            df = pd.read_csv(os.path.join(path, file))\r\n            globals()[var_name] = df\r\n            crowders[var_name] = df\r\n\r\n    # Define styles\r\n    styles = {\r\n        'buffer': {'x': [0], 'y': [EGly['D_Na_[um2/s]'][0]], 'yerr': [EGly['D_Na_err_[um2/s]'][0]], 'color': '#868788', 'marker': '*', 'ms': 9.5, 'mec': '#000000', 'label': 'buffer'},\r\n        'EGly': {'color': '#2d642a', 'marker': '.', 'ms': 12, 'mec': '#000000', 'label': 'EGly'},\r\n        'PEG200': {'color': '#b3daff', 'marker': 'd', 'ms': 7, 'mec': '#000000', 'label': 'PEG 200'},\r\n        'PEG400': {'color': '#640024', 'marker': '^', 'ms': 7, 'mec': '#000000', 'label': 'PEG 400'},\r\n        'PEG600': {'color': '#ff730f', 'marker': 'h', 'ms': 7, 'mec': '#000000', 'label': 'PEG 600'},\r\n        'PEG1000': {'color': '#fed85d', 'marker': 'P', 'ms': 6.5, 'mec': '#000000', 'label': 'PEG 1k'},\r\n        'PEG1500': {'color': '#142cd7', 'marker': 'p', 'ms': 7, 'mec': '#000000', 'label': 'PEG 1.5k'},\r\n        'PEG3000': {'color': '#ac1416', 'marker': 's', 'ms': 6, 'mec': '#000000', 'label': 'PEG 3k'},\r\n        'PEG6000': {'color': '#674ea7', 'marker': 'D', 'ms': 5.5, 'mec': '#000000', 'label': 'PEG 6k'},\r\n        'PEG12000': {'color': '#709d74', 'marker': 'v', 'ms': 7, 'mec': '#000000', 'label': 'PEG 12k'},\r\n        'PEG20000': {'color': '#00cccc', 'marker': 'X', 'ms': 7, 'mec': '#000000', 'label': 'PEG 20k'},\r\n        'PEG35000': {'color': '#b28092', 'marker': 'h', 'ms': 7, 'mec': '#000000', 'label': 'PEG 35k'}\r\n    }\r\n\r\n    # Diffusion coefficient of Na in buffer\r\n    Na_0 = (0, EGly['D_Na_[um2/s]'][0])\r\n    plt.figure(figsize=(7, 5))\r\n\r\n    # Loop through styles and crowders\r\n    for name, style in styles.items():\r\n        if name in crowders:  # Check if the crowder exists in the data\r\n            df = crowders[name]\r\n            slope, b_x, b_y, r_squared = uts.linear_fit_with_fixed_point(df['wt_%'], df['D_Na_[um2/s]'], Na_0)\r\n            x_range = np.linspace(np.min(df['wt_%']), 19, 100)\r\n            regression_line = slope * (x_range - b_x) + b_y\r\n            plt.plot(x_range, regression_line, color=style['color'], linestyle='--', lw=1.5)\r\n            plt.errorbar(df['wt_%'][1:], df['D_Na_[um2/s]'][1:], yerr=df['D_Na_err_[um2/s]'][1:],\r\n                         color=style['color'], marker=style['marker'], mfc=style['color'], mec=style['mec'],\r\n                         linestyle='none', lw=1, ms=style['ms'], elinewidth=1, capsize=3, capthick=1,\r\n                         label=f\"{style['label']}, R$^{2}$ = {r_squared:.3f}\")\r\n        elif 'x' in style and 'y' in style:  # Handle special cases like \"buffer\"\r\n            plt.errorbar(style['x'], style['y'], yerr=style.get('yerr', None),\r\n                         color=style['color'], marker=style['marker'], mfc=style['color'], mec=style['mec'],\r\n                         linestyle='none', lw=1, ms=style['ms'], elinewidth=1, capsize=3, capthick=1,\r\n                         label=style['label'])\r\n\r\n    # Final plot styling and saving\r\n    plt.title('$D_{Na^{+}}$ vs crowder wt.% change', fontsize=18)\r\n    plt.xlabel('crowder wt.%', fontsize=16)\r\n    plt.ylabel('$D_{Na^{+}}$ [µm$^{2}$/s]', fontsize=16)\r\n    plt.xticks(fontsize=12)\r\n    plt.yticks(fontsize=12)\r\n    plt.xlim(-1, 19)\r\n    plt.ylim(250,1550)\r\n    plt.legend(frameon=True, loc='lower left', fontsize=8)\r\n    plt.savefig('Plots/D_Na_vs_crowder_weight_percent.png', bbox_inches='tight', transparent=True, dpi=300)\r\n    return plt.show()\r\n\r\n\r\ndef crowder_self_diffusion_coefficients_in_their_mass_functions():\r\n\r\n    # Load CSV files into global variables and dictionary\r\n    path = 'source_data/D_Na_and_D_crowder'\r\n    crowders = {}\r\n    for file in os.listdir(path):\r\n        if file.endswith('.csv'):\r\n            var_name = os.path.splitext(file)[0]\r\n            df = pd.read_csv(os.path.join(path, file))\r\n            globals()[var_name] = df\r\n            crowders[var_name] = df\r\n\r\n    # Define styles\r\n    styles = {\r\n        'EGly': {'color': '#2d642a', 'marker': '.', 'ms': 12, 'mec': '#000000', 'label': 'EGly'},\r\n        'PEG200': {'color': '#b3daff', 'marker': 'd', 'ms': 7, 'mec': '#000000', 'label': 'PEG 200'},\r\n        'PEG400': {'color': '#640024', 'marker': '^', 'ms': 7, 'mec': '#000000', 'label': 'PEG 400'},\r\n        'PEG600': {'color': '#ff730f', 'marker': 'h', 'ms': 7, 'mec': '#000000', 'label': 'PEG 600'},\r\n        'PEG1000': {'color': '#fed85d', 'marker': 'P', 'ms': 6.5, 'mec': '#000000', 'label': 'PEG 1k'},\r\n        'PEG1500': {'color': '#142cd7', 'marker': 'p', 'ms': 7, 'mec': '#000000', 'label': 'PEG 1.5k'},\r\n        'PEG3000': {'color': '#ac1416', 'marker': 's', 'ms': 6, 'mec': '#000000', 'label': 'PEG 3k'},\r\n        'PEG6000': {'color': '#674ea7', 'marker': 'D', 'ms': 5.5, 'mec': '#000000', 'label': 'PEG 6k'},\r\n        'PEG12000': {'color': '#709d74', 'marker': 'v', 'ms': 7, 'mec': '#000000', 'label': 'PEG 12k'},\r\n        'PEG20000': {'color': '#00cccc', 'marker': 'X', 'ms': 7, 'mec': '#000000', 'label': 'PEG 20k'},\r\n        'PEG35000': {'color': '#b28092', 'marker': 'h', 'ms': 7, 'mec': '#000000', 'label': 'PEG 35k'}\r\n    }\r\n\r\n    plt.figure(figsize=(7, 5))\r\n\r\n    # Loop through styles and crowders\r\n    for name, style in styles.items():\r\n        df = crowders[name]\r\n        a, b, c, r_squared = uts.exponential_fit_with_r_squared(df['wt_%'][1:], df['D_crowder_[um2/s]'][1:])\r\n        x_range = np.linspace(np.min(df['wt_%']), 19, 100)\r\n        plt.plot(x_range, uts.exponential_model(x_range, a, b, c), color=style['color'], linestyle='--', lw=1.5)\r\n        plt.errorbar(df['wt_%'][1:], df['D_crowder_[um2/s]'][1:], yerr=df['D_crowder_err_[um2/s]'][1:],\r\n                     color=style['color'], marker=style['marker'], mfc=style['color'], mec=style['mec'],\r\n                     linestyle='none', lw=1, ms=style['ms'], elinewidth=1, capsize=3, capthick=1,\r\n                     label=f\"{style['label']}, R$^{2}$ = {r_squared:.3f}\")\r\n\r\n    # Final plot styling and saving\r\n    plt.title('$D_{crowder}$ in their wt.% functions', fontsize=18)\r\n    plt.xlabel('crowder wt.%', fontsize=16)\r\n    plt.ylabel('$D_{crowder}$ [µm$^{2}$/s]', fontsize=16)\r\n    plt.xticks(fontsize=12)\r\n    plt.yticks(fontsize=12)\r\n    plt.xlim(-1, 19)\r\n    plt.legend(frameon=True, loc='upper right', fontsize=8)\r\n    plt.savefig('Plots/crowder_self_diffusion_coefficients_in_their_mass_functions.png', bbox_inches='tight', transparent=True, dpi=300)\r\n    return plt.show()\r\n\r\n\r\ndef kappa_results_for_PEG():\r\n    # transforming data\r\n    kappa_fitting_output = K_fit.kappa_fitting()\r\n    df_kappa = pd.DataFrame([{\r\n        \"crowder\": k,\r\n        \"kappa\": float(v.split('±')[0]),\r\n        \"kappa_err\": float(v.split('±')[1])\r\n    } for k, v in kappa_fitting_output.items()])\r\n\r\n    # choosing only values for PEGs and sorting data\r\n    required_order = [\r\n        \"EGly\", \"PEG200\", \"PEG400\", \"PEG600\", \"PEG1000\", \"PEG1500\",\r\n        \"PEG3000\", \"PEG6000\", \"PEG12000\", \"PEG20000\", \"PEG35000\"]\r\n    sorted_kappa = df_kappa[df_kappa['crowder'].isin(required_order)]\r\n    sorted_kappa = sorted_kappa.set_index('crowder').loc[required_order].reset_index()\r\n\r\n    # calculating weighted average of kappa for PEGs\r\n    kappa_avg, kappa_avg_err =  uts.weighted_average_with_error(sorted_kappa['kappa'], sorted_kappa['kappa_err'])\r\n\r\n    # plotting\r\n    plt.figure(figsize=(7,5))\r\n\r\n    plt.bar(sorted_kappa['crowder'], sorted_kappa['kappa'], yerr=sorted_kappa['kappa_err'],\r\n            color='#dfb37f', capsize=3, error_kw={'ecolor': '#505050', 'elinewidth': 1.2}, label = '$κ$ values with \\nrelated errors')\r\n    plt.axhline(y=kappa_avg, color='black', linestyle='--', label = '$κ_{avg}$')\r\n    plt.axhline(y = kappa_avg + kappa_avg_err, color='black', linestyle='-', label = '$κ_{err}$')\r\n    plt.axhline(y = kappa_avg - kappa_avg_err, color='black', linestyle='-')\r\n    x_min, x_max = plt.gca().get_xlim()  # Get current x-axis limits\r\n    plt.fill_betweenx(y=[kappa_avg + kappa_avg_err, kappa_avg - kappa_avg_err], x1=x_min, x2=x_max, color='grey', alpha=0.4)\r\n\r\n    plt.title('$κ_{crowder-Na^{+}}$ for EGly and PEGs', fontsize=18)\r\n    plt.xlabel('', fontsize=16)\r\n    plt.ylabel('$κ_{crowder-Na^{+}}$ [M$^{-1}$]', fontsize=16)\r\n    plt.xticks(fontsize=12, rotation=45)\r\n    plt.yticks(fontsize=12)\r\n    plt.xlim(x_min, x_max)\r\n    plt.ylim(0,0.31)\r\n    plt.legend(frameon=True, loc='upper right', fontsize=8)\r\n    plt.savefig('Plots/kappa_results_for_PEGs.png', bbox_inches='tight', transparent=True, dpi=300)\r\n    return plt.show()\r\n\r\n\r\ndef PEG_coil_to_mesh_transition():\r\n    value = uts.crowders_properties()\r\n\r\n    plt.figure(figsize=(7, 5))\r\n\r\n    a, b, r_squared = uts.power_fit_with_r_squared(value['MW_[g/mol]'].iloc[1:-3], value['c*_[g/cm3]'].iloc[1:-3])\r\n    x_range = np.linspace(62.07, 50000, 5000)\r\n    plt.errorbar(x_range, uts.power_model(x_range, a, b), color='#142cd7', marker='', linestyle='-')\r\n\r\n    plt.errorbar(value['MW_[g/mol]'].iloc[:-3], value['c*_[g/cm3]'].iloc[:-3], color='#142cd7', marker='.',\r\n                             mec='#000000', linestyle='none', lw=1, ms=12, elinewidth=1, capsize=3, capthick=1)\r\n\r\n    plt.text(1500, 0.45, '$C_{crowder}$ > $C^{*}$\\n     mesh', fontsize=14)\r\n    plt.text(150, 0.1, '$C_{crowder}$ < $C^{*}$\\n     coil', fontsize=14)\r\n\r\n    plt.title('$C^{*}$ vs $MW_{crowder}$ for PEGs', fontsize=18)\r\n    plt.xlabel('$MW_{crowder}$ [g/mol]', fontsize=16)\r\n    plt.ylabel('$C^{*}$ [g/cm$^{3}$]', fontsize=16)\r\n    plt.xticks(fontsize=12)\r\n    plt.yticks(fontsize=12)\r\n    plt.xscale('log')\r\n    plt.xlim(90, 50000)\r\n    plt.ylim(0, 1.05)\r\n    # plt.legend(frameon=True, loc='upper right', fontsize=8)\r\n    plt.savefig('Plots/PEG_coil_to_mesh_transition.png', bbox_inches='tight', transparent=True, dpi=300)\r\n    return plt.show()\r\n\r\n\r\ndef refractive_index_of_crowder_solutions():\r\n    df = K_fit.calculate_average_RI_with_error_of_sample()\r\n\r\n    # Adjust the plotting styles\r\n    styles = {\r\n        'EGly': {'color': '#2d642a', 'marker': '.', 'ms': 12, 'mec': '#000000', 'label': 'EGly'},\r\n        'PEG200': {'color': '#b3daff', 'marker': 'd', 'ms': 7, 'mec': '#000000', 'label': 'PEG 200'},\r\n        'PEG400': {'color': '#640024', 'marker': '^', 'ms': 7, 'mec': '#000000', 'label': 'PEG 400'},\r\n        'PEG600': {'color': '#ff730f', 'marker': 'h', 'ms': 7, 'mec': '#000000', 'label': 'PEG 600'},\r\n        'PEG1000': {'color': '#fed85d', 'marker': 'P', 'ms': 6.5, 'mec': '#000000', 'label': 'PEG 1k'},\r\n        'PEG1500': {'color': '#142cd7', 'marker': 'p', 'ms': 7, 'mec': '#000000', 'label': 'PEG 1.5k'},\r\n        'PEG3000': {'color': '#ac1416', 'marker': 's', 'ms': 6, 'mec': '#000000', 'label': 'PEG 3k'},\r\n        'PEG6000': {'color': '#674ea7', 'marker': 'D', 'ms': 5.5, 'mec': '#000000', 'label': 'PEG 6k'},\r\n        'PEG12000': {'color': '#709d74', 'marker': 'v', 'ms': 7, 'mec': '#000000', 'label': 'PEG 12k'},\r\n        'PEG20000': {'color': '#00cccc', 'marker': 'X', 'ms': 7, 'mec': '#000000', 'label': 'PEG 20k'},\r\n        'PEG35000': {'color': '#b28092', 'marker': 'h', 'ms': 7, 'mec': '#000000', 'label': 'PEG 35k'}}\r\n\r\n    # plotting\r\n    plt.figure(figsize=(7, 5))\r\n    for crowder, style in styles.items():\r\n        values = df[crowder].str.split('±').str[0].astype(float)  # Extract values before ±\r\n        errors = df[crowder].str.split('±').str[1].astype(float)  # Extract errors after ±\r\n\r\n        x_0 = [0, 1.337]\r\n        slope, b_x, b_y, r_squared = uts.linear_fit_with_fixed_point(df['wt_%'], values, x_0)\r\n        x_range = np.linspace(0, 42, 100)\r\n        regression_line = slope * (x_range - b_x) + b_y\r\n        plt.plot(x_range, regression_line, color=style['color'], linestyle='--', lw=1.5)\r\n\r\n        plt.errorbar(df['wt_%'], values, yerr=errors, color=style['color'], marker=style['marker'],\r\n                     mec=style['mec'], linestyle='none', lw=1, ms=style['ms'], elinewidth=1, capsize=3,\r\n                     capthick=1, label=f'{style['label']}, R²={r_squared:.3f}')\r\n\r\n    plt.title('$RI$ of crowder solutions', fontsize=18)\r\n    plt.xlabel('crowder wt.%', fontsize=16)\r\n    plt.ylabel('$RI$', fontsize=16)\r\n    plt.xticks(fontsize=12)\r\n    plt.yticks(fontsize=12)\r\n    plt.xlim(-2, 42)\r\n    plt.legend(frameon=True, loc='upper left', fontsize=8)\r\n    plt.savefig('plots/refractive_index_of_crowder_solutions.png', bbox_inches='tight', transparent=True, dpi=300)\r\n    return plt.show()\r\n\r\n\r\npd.set_option('display.max_rows', None)  # Show all rows\r\npd.set_option('display.max_columns', None)  # Show all columns\r\npd.set_option('display.width', None)  # Ensure the table fits the screen width\r\n# print(uts.crowders_properties())\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/plots.py b/plots.py
--- a/plots.py	(revision ef7d7b50a9c0b35162556fede902063426ceb093)
+++ b/plots.py	(date 1734541665502)
@@ -334,11 +334,55 @@
 pd.set_option('display.max_rows', None)  # Show all rows
 pd.set_option('display.max_columns', None)  # Show all columns
 pd.set_option('display.width', None)  # Ensure the table fits the screen width
-# print(uts.crowders_properties())
+print(uts.crowders_properties().iloc[0:11, 1])
+
+
+
+
+# Correcting the DataFrame columns and index
+column_labels = ["EGly", "PEG200", "PEG400", "PEG600", "PEG1000", "PEG1500", "PEG3000", "PEG6000", "PEG12000", "PEG20000", "PEG35000"]
+column_points = uts.crowders_properties().iloc[0:11, 0]
+row_labels = [2.5, 5, 7.5, 10, 12.5, 15, 20, 25, 30, 40]
 
+df = uts.mesh_sizes().apply(pd.to_numeric, errors='coerce')
+print(df)
 
+# Flattening the DataFrame to extract values and corresponding weights and samples
+flat_data = [(col, value, weight) for col, series in df.items() for value, weight in zip(series, row_labels)]
 
+# Sorting values to create a color gradient from white to black
+sorted_values = sorted([value for _, value, _ in flat_data if not pd.isna(value)])
+color_map = {np.round(value, 6): i / (len(sorted_values) - 1) for i, value in enumerate(sorted_values)}
 
+# Plot setup
+plt.figure(figsize=(7, 5))
+for col, value, weight in flat_data:
+    if not pd.isna(value):
+        color_value = color_map[np.round(value, 6)]  # Rounding values for key lookup
+        y = column_points[column_labels.index(col)]
+        plt.scatter(weight, y, color=str(1 - color_value), edgecolor='black', s=50)  # color transition from white to black
+
+# plt.xscale('log')
+# plt.yscale('log')
+plt.xticks(fontsize=12)
+# plt.yticks(column_points, column_labels)  # Set y-ticks to sample types with their corresponding points
+plt.yticks(fontsize=12)
+plt.ylabel('Sample Type (corresponding values)')
+plt.xlabel('Weight Percent (%)')
+plt.title('Value Distribution with Color Gradient by Weight Percent')
+# plt.grid(True, which="both", ls="--")
+# plt.ylim(400, 40000)
+plt.show()
+
+# plt.title('$RI$ of crowder solutions', fontsize=18)
+# plt.xlabel('crowder wt.%', fontsize=16)
+# plt.ylabel('$RI$', fontsize=16)
+# plt.xticks(fontsize=12)
+# plt.yticks(fontsize=12)
+# # plt.xlim(-2, 42)
+# plt.legend(frameon=True, loc='upper left', fontsize=8)
+# # plt.savefig('plots/refractive_index_of_crowder_solutions.png', bbox_inches='tight', transparent=True, dpi=300)
+# plt.show()
 
 
 
Index: K_dependency.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import pandas as pd\r\nimport numpy as np\r\nimport uncertainties as unc\r\nfrom uncertainties import umath\r\nimport utils as uts\r\n\r\n\r\ndef choose_peg(data, peg):\r\n    df = data[data['crowder'] == peg]\r\n    return df\r\n\r\n\r\ndef fit_polynomial_to_K(data):\r\n    names = data['crowder'].unique()\r\n\r\n    coeffs_dict = {}\r\n\r\n    for name in names:\r\n        x = np.array(choose_peg(data, name)['concentration [M]'], dtype=np.float64)\r\n        y, y_err = uts.get_float_uncertainty(choose_peg(data, name)['K'].apply(lambda x: umath.log(x)))\r\n\r\n        coefficients, cov_matrix = np.polyfit(x, y, 2, w=1 / y_err, cov=True)\r\n\r\n        errors = np.sqrt(np.diag(cov_matrix))\r\n\r\n        ufloat_coefficients = [unc.ufloat(coefficients[i], errors[i]) for i in range(len(coefficients))]\r\n\r\n        coeffs_dict[name] = ufloat_coefficients\r\n\r\n    # Convert the dictionary to a DataFrame\r\n    coeffs_df = pd.DataFrame.from_dict(coeffs_dict, orient='index',\r\n                                       columns=['a2', 'a1', 'a0'])\r\n\r\n    # Reset the index to make 'peg' a column\r\n    coeffs_df = coeffs_df.reset_index().rename(columns={'index': 'crowder'})\r\n\r\n    return coeffs_df\r\n\r\n\r\ndef fit_coefficients_of_quadratic_fit():\r\n    data = pd.read_csv('./results/K_DNA-DNA_in_crowder_solutions.csv')\r\n\r\n    data.dropna(inplace=True)\r\n\r\n    # changing +- sign to the unc float objects\r\n    for col in data.columns:\r\n        data[col] = data[col].map(uts.convert_to_ufloat)\r\n\r\n    data = pd.merge(data, pd.DataFrame(uts.crowders_properties()), left_on='crowder', right_index=True)\r\n\r\n    density = 1\r\n\r\n    data['concentration [M]'] = data['wt_%'] * density / data['MW_[g/mol]'] * 10 #possibly we will modify here the density\r\n\r\n    coefficients = fit_polynomial_to_K(data)\r\n    coefficients = pd.merge(coefficients, pd.DataFrame(uts.crowders_properties()), left_on='crowder', right_index=True)\r\n\r\n    return coefficients\r\n\r\n\r\n###########  theretical calculations ##########################\r\ndef calculate_a1_a2_theoretical_values(c0=uts.c0, zi=uts.zi, a=uts.a, Km=uts.Km, reagent_Rg=uts.Rg_ssDNA,\r\n                                       Temperature=uts.T):\r\n    alpha = np.sqrt((uts.eps * uts.kb * Temperature) / (2 * uts.Na * uts.qe ** 2))\r\n\r\n    Zi = zi * uts.qe / (4 * np.pi * uts.eps)\r\n\r\n    numerator = uts.Na * zi * uts.qe * Zi * np.sqrt(c0)\r\n    denominator = 3 * np.sqrt(6) * (3 * a + 2) ** (3 / 2) * np.e * alpha\r\n\r\n    lambd = numerator / denominator\r\n\r\n    theory_a2 = -(4 * a + 2) * lambd / (uts.R * Temperature) * Km ** 2\r\n\r\n    theory_a1 = 2 * (5 * a + 3) * lambd / (uts.R * Temperature) * Km\r\n\r\n    return theory_a1, theory_a2\r\n\r\npd.set_option('display.max_rows', None)  # Show all rows\r\npd.set_option('display.max_columns', None)  # Show all columns\r\npd.set_option('display.width', None)  # Ensure the table fits the screen width\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/K_dependency.py b/K_dependency.py
--- a/K_dependency.py	(revision ef7d7b50a9c0b35162556fede902063426ceb093)
+++ b/K_dependency.py	(date 1734528918915)
@@ -76,10 +76,6 @@
 
     return theory_a1, theory_a2
 
-pd.set_option('display.max_rows', None)  # Show all rows
-pd.set_option('display.max_columns', None)  # Show all columns
-pd.set_option('display.width', None)  # Ensure the table fits the screen width
-
 
 
 
Index: utils.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import numpy as np\r\nimport uncertainties as unc\r\nimport math\r\nfrom scipy.stats import linregress\r\nimport pandas as pd\r\nfrom scipy.optimize import curve_fit\r\n\r\n\r\n# physical constants\r\neps = 8.8541878188 * 10 ** (-12) * 81  # vacuum * water relative permittivity\r\nNa = 6.02214076 * 10 ** (23)  # avogadro number\r\nqe = 1.60217663 * 10 ** (-19)  # elementary charge of electrion in Culomb\r\nkb = 1.380649 * 10 ** (-23)  # boltzman constant\r\nR = 8.31446261815324  #\r\n\r\n# experimental data from our studies\r\nc0 = 35  # concentration of Na+ in mmol which is equal to mol/m^3\r\nzi = 13  # charge of the ssDNA 13bp\r\na = 0.0754 / 0.1754 * 4 + 0.0246 / 0.1754  # the anions part of the ionic strength HPO42- and H2PO4-\r\nKm = 0.14  # complexation constant of the PEG - Na complexation\r\nRg_ssDNA = 1.3  # radius of ssDNA, I have chosen this arbitraly\r\nT = 298.15  # temperature for the reaction\r\n\r\n\r\n# Function to convert strings with uncertainties to ufloat\r\ndef convert_to_ufloat(value):\r\n    if isinstance(value, str):  # Check if the value is a string\r\n        # Normalize the string by replacing \"±\" and \"+-\" with spaces\r\n        value = value.replace('±', ' ').replace('+-', ' ')\r\n        parts = value.split()  # Split by whitespace\r\n\r\n        # Check if we have two parts (nominal and uncertainty)\r\n        if len(parts) == 2:\r\n            try:\r\n                return unc.ufloat(float(parts[0]), float(parts[1]))  # Create ufloat from parts\r\n            except ValueError:\r\n                return value  # Return original value if conversion fails\r\n        else:\r\n            try:\r\n                return float(value)  # If it's just a number, convert directly\r\n            except ValueError:\r\n                return value  # Return original value if conversion fails\r\n    return value  # Return as is if it's already a number\r\n\r\n\r\n# from unc.float extracts value and error\r\ndef get_float_uncertainty(column):\r\n    values = np.array([x.nominal_value for x in column], dtype=np.float64)\r\n    uncertainty = np.array([x.std_dev for x in column], dtype=np.float64)\r\n    return values, uncertainty\r\n\r\n\r\ndef weighted_average_with_error(data, errors):\r\n    weights = 1 / errors ** 2\r\n    weighted_avg = np.sum(data * weights) / np.sum(weights)\r\n    weighted_avg_error = np.sqrt(1 / np.sum(weights))\r\n    return weighted_avg, weighted_avg_error\r\n\r\n\r\n# standard linear fit\r\ndef linear_fit_normal(x, y):\r\n    y_value, y_error = get_float_uncertainty(y)\r\n    slope, intercept, r_value, p_value, std_err = linregress(x, y_value)\r\n    r_squared = r_value ** 2\r\n    return slope, intercept, r_squared\r\n\r\n\r\ndef linear_fit_with_fixed_point(x, y, fixed_point):\r\n    b_x, b_y = fixed_point\r\n    a = np.sum((x - b_x) * (y - b_y)) / np.sum((x - b_x) ** 2)\r\n    y_pred = a * (x - b_x) + b_y\r\n    y_mean = np.mean(y)\r\n    sst = np.sum((y - y_mean) ** 2)\r\n    ssr = np.sum((y - y_pred) ** 2)\r\n    r_squared = 1 - (ssr / sst)\r\n    return a, b_x, b_y, r_squared\r\n\r\n\r\ndef exponential_model(x, a, b, c):\r\n    return a * np.exp(b * x) + c\r\n\r\n\r\ndef exponential_fit_with_r_squared(x, y):\r\n    popt, pcov = curve_fit(exponential_model, x, y, p0=(1, 0.1, 1), maxfev=10000)\r\n    a, b, c = popt\r\n    y_fit = exponential_model(x, *popt)\r\n    residuals = y - y_fit\r\n    ss_res = np.sum(residuals**2)\r\n    ss_tot = np.sum((y - np.mean(y))**2)\r\n    r_squared = 1 - (ss_res / ss_tot)\r\n    return a, b, c, r_squared\r\n\r\n\r\ndef power_model(x, a, b):\r\n    return a * x**b\r\n\r\n\r\ndef power_fit_with_r_squared(x, y):\r\n    popt, pcov = curve_fit(power_model, x, y, p0=(1, 1), maxfev=10000)\r\n    a, b = popt\r\n    y_fit = power_model(x, a, b)\r\n    residuals = y - y_fit\r\n    ss_res = np.sum(residuals**2)\r\n    ss_tot = np.sum((y - np.mean(y))**2)\r\n    r_squared = 1 - (ss_res / ss_tot)\r\n    return a, b, r_squared\r\n\r\n\r\n# log function for K fitting\r\ndef logdef(x):\r\n    b = math.floor(math.log10(abs(x)))\r\n    a = x * 10 ** (-b)\r\n    c = (a, b)\r\n    return c\r\n\r\n\r\n# returns all properties of crowders, such as MW, No of monomers, Rg, Rh, etc.\r\ndef crowders_properties():\r\n    data = {\r\n        'MW_[g/mol]': [62.07, 200, 400, 600, 1000, 1500, 3000, 6000, 12000, 20000, 35000, 6000, 70000, 400000], # crowder molecular weight\r\n        'No_mono': [1, 4.131, 8.672, 13.212, 22.292, 33.643, 67.695, 135.800, 272.009, 453.620, 794.143, 37.005, 431.726, 1168.566], # no of crowder monomers\r\n        'd_coef': [0.00094, 0.0012, 0.0013, 0.00135, 0.0014, 0.00145, 0.0015, 0.00155, 0.0016, 0.00165, 0.0017, 0.0004, 0.00055, 0.00035]} # coefficient for density of crowder solutions ρ=ρ0+A⋅C, where C is crowder wt.% and ρ0 = 0.997 g/cm3\r\n    index = [\"EGly\", \"PEG200\", \"PEG400\", \"PEG600\", \"PEG1000\", \"PEG1500\", \"PEG3000\", \"PEG6000\", \"PEG12000\", \"PEG20000\", \"PEG35000\", \"Dextran6000\", \"Dextran70000\", \"Ficoll400000\"]\r\n    value = pd.DataFrame(data, index=index)\r\n    value['Rg_[nm]'] = 0.215 * value['MW_[g/mol]'] ** 0.583 / 10 # crowder radius of gyration\r\n    value.loc['Dextran6000', 'Rg_[nm]'] = 1.75\r\n    value.loc['Dextran70000', 'Rg_[nm]'] = 7.5\r\n    value.loc['Ficoll400000', 'Rg_[nm]'] = 12\r\n    value['Rg_err_[nm]'] = 0.215 * value['MW_[g/mol]'] ** 0.031 / 10 # crowder error for radius of gyration\r\n    value.loc['Dextran6000', 'Rg_err_[nm]'] = 0.25\r\n    value.loc['Dextran70000', 'Rg_err_[nm]'] = 0.5\r\n    value.loc['Ficoll400000', 'Rg_err_[nm]'] = 1.5\r\n    value['Rh_[nm]'] = 0.145 * value['MW_[g/mol]'] ** 0.571 / 10 # crowder hydrodynamic radius\r\n    value.loc['Dextran6000', 'Rh_[nm]'] = 1.15\r\n    value.loc['Dextran70000', 'Rh_[nm]'] = 5.25\r\n    value.loc['Ficoll400000', 'Rh_[nm]'] = 9\r\n    value['Rh_err_[nm]'] = 0.145 * value['MW_[g/mol]'] ** 0.009 / 10 # crowder error for hydrodynamic radius\r\n    value.loc['Dextran6000', 'Rh_err_[nm]'] = 0.15\r\n    value.loc['Dextran70000', 'Rh_err_[nm]'] = 0.75\r\n    value.loc['Ficoll400000', 'Rh_err_[nm]'] = 1\r\n    value['V_Rg_[nm3]'] = 4/3 * np.pi * value['Rg_[nm]'] ** 3 # volumes of crowder coils if they are a coil\r\n    value['V_Rg_err_[nm3]'] = 4 * np.pi * value['Rg_[nm]'] ** 2 * value['Rg_err_[nm]'] # error for volumes of crowder coils if they are a coil\r\n    value['c*_[g/cm3]'] = value['MW_[g/mol]'] / (Na * value['V_Rg_[nm3]']) * 1e21 # concentration at which polymer starts to overlap calculated using scaling theories for polymer solutions from de Gennes, P. G. \"Scaling Concepts in Polymer Physics.\" Cornell University Press, 1979.\r\n    return(value)\r\n\r\n# mesh sizes for PEGs if mesh\r\ndef mesh_sizes():\r\n    properties = crowders_properties().loc['EGly':'PEG35000', ]\r\n\r\n    # crowders\r\n    crowders = [\r\n        \"EGly\", \"PEG200\", \"PEG400\", \"PEG600\", \"PEG1000\", \"PEG1500\",\r\n        \"PEG3000\", \"PEG6000\", \"PEG12000\", \"PEG20000\", \"PEG35000\"]\r\n\r\n    # weight percents of crowders\r\n    wt_percents = [2.5, 5 , 7.5, 10, 12.5, 15, 20, 25, 30, 40]\r\n\r\n    row_names = [\r\n        \"2.5_wt%\", \"5_wt%\", \"7.5_wt%\", \"10_wt%\", \"12.5_wt%\",\r\n        \"15_wt%\", \"20_wt%\", \"25_wt%\", \"30_wt%\", \"40_wt%\"]\r\n\r\n    # mesh sizes [nm] calculated from equation ξ = Rg * (c/c*)**-β where β is 0.75 from Ulrich R.D. (1978) P. J. Flory. In: Ulrich R.D. (eds) Macromolecular Science. Contemporary Topics in Polymer Science, vol 1. Springer, Boston, MA. https://doi.org/10.1007/978-1-4684-2853-7_5\r\n    data = [[properties.loc[crowder, 'Rg_[nm]'] * ((wt_percent / (100 / (0.997 + wt_percent * properties.loc[crowder, 'd_coef']))) / properties.loc[crowder, 'c*_[g/cm3]']) ** -0.75 for crowder in crowders] for wt_percent in wt_percents]\r\n    df = pd.DataFrame(data, index=row_names, columns=crowders)\r\n\r\n    # assigns 'Rg' to points where polymers are still coils (in this regime polymer is described by radius of gyration)\r\n    df = df.astype(object)\r\n    df.loc[:,'EGly'] = 'Rg'\r\n    df.loc[:,'PEG200'] = 'Rg'\r\n    df.loc[:,'PEG400'] = 'Rg'\r\n    df.loc[:'30_wt%','PEG600'] = 'Rg'\r\n    df.loc[:'20_wt%','PEG1000'] = 'Rg'\r\n    df.loc[:'15_wt%','PEG1500'] = 'Rg'\r\n    df.loc[:'7.5_wt%','PEG3000'] = 'Rg'\r\n    df.loc[:'5_wt%','PEG6000'] = 'Rg'\r\n    df.loc[:'2.5_wt%','PEG12000'] = 'Rg'\r\n    df.loc[:'2.5_wt%','PEG20000'] = 'Rg'\r\n    return df\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/utils.py b/utils.py
--- a/utils.py	(revision ef7d7b50a9c0b35162556fede902063426ceb093)
+++ b/utils.py	(date 1734532034040)
@@ -196,4 +196,3 @@
 
 
 
-
